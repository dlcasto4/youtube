/*

 Copyright 2016 Google Inc. All Rights Reserved.

 Licensed under the W3C SOFTWARE AND DOCUMENT NOTICE AND LICENSE.

  https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document

*/
(function (window, document) {
    /**
     * Represents an entry for an observed element.
     */
    class IntersectionObserverEntry {
        constructor(entry) {
            this.time = entry.time;
            this.target = entry.target;
            this.rootBounds = entry.rootBounds || this.emptyRect();
            this.boundingClientRect = entry.boundingClientRect;
            this.intersectionRect = entry.intersectionRect || this.emptyRect();
            this.isIntersecting = !!entry.intersectionRect;
            const elementArea = this.boundingClientRect.width * this.boundingClientRect.height;
            const intersectionArea = this.intersectionRect.width * this.intersectionRect.height;
            this.intersectionRatio = elementArea
                ? intersectionArea / elementArea
                : this.isIntersecting
                ? 1
                : 0;
        }

        /**
         * Returns an empty rectangle object.
         */
        emptyRect() {
            return { top: 0, bottom: 0, left: 0, right: 0, width: 0, height: 0 };
        }
    }

    /**
     * Polyfill for IntersectionObserver.
     */
    class IntersectionObserver {
        constructor(callback, options = {}) {
            if (typeof callback !== "function") {
                throw new Error("callback must be a function");
            }

            // Set root element
            this.root = options.root || null;
            if (this.root && this.root.nodeType !== 1) {
                throw new Error("root must be an Element");
            }

            // Set root margin and threshold
            this.rootMargin = this.parseRootMargin(options.rootMargin);
            this.thresholds = this.initThresholds(options.threshold);

            this.callback = callback;
            this.targets = new Map();
            this.monitoring = false;
            this.pollingInterval = 100; // Adjust based on performance needs

            // Bind the process function
            this.process = this.throttle(this.processEntries.bind(this), this.pollingInterval);
        }

        /**
         * Parses root margin (e.g., "10px 20px").
         */
        parseRootMargin(rootMargin = "0px") {
            return rootMargin.split(/\s+/).map((margin) => {
                const match = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
                if (!match) throw new Error("rootMargin must be in pixels or percent");
                return { value: parseFloat(match[1]), unit: match[2] };
            });
        }

        /**
         * Initializes threshold array.
         */
        initThresholds(threshold = [0]) {
            if (!Array.isArray(threshold)) {
                threshold = [threshold];
            }
            return threshold
                .filter((value) => value >= 0 && value <= 1)
                .sort((a, b) => a - b);
        }

        /**
         * Starts observing an element.
         */
        observe(target) {
            if (!target || target.nodeType !== 1) {
                throw new Error("target must be an Element");
            }

            if (!this.targets.has(target)) {
                this.targets.set(target, { entry: null });
                if (!this.monitoring) {
                    this.startMonitoring();
                }
            }
        }

        /**
         * Stops observing an element.
         */
        unobserve(target) {
            this.targets.delete(target);
            if (!this.targets.size) {
                this.stopMonitoring();
            }
        }

        /**
         * Disconnects all targets.
         */
        disconnect() {
            this.targets.clear();
            this.stopMonitoring();
        }

        /**
         * Processes observed entries and triggers callback.
         */
        processEntries() {
            const rootBounds = this.getRootBounds();
            const entries = [];

            this.targets.forEach((data, target) => {
                const boundingClientRect = this.getBoundingClientRect(target);
                const intersectionRect = this.computeIntersection(target, rootBounds, boundingClientRect);
                const entry = new IntersectionObserverEntry({
                    time: performance.now(),
                    target,
                    rootBounds,
                    boundingClientRect,
                    intersectionRect,
                });

                if (!data.entry || this.hasIntersectionChanged(data.entry, entry)) {
                    this.targets.set(target, { entry });
                    entries.push(entry);
                }
            });

            if (entries.length) {
                this.callback(entries, this);
            }
        }

        /**
         * Starts monitoring targets.
         */
        startMonitoring() {
            this.monitoring = true;
            window.addEventListener("resize", this.process, true);
            document.addEventListener("scroll", this.process, true);
            this.process();
        }

        /**
         * Stops monitoring targets.
         */
        stopMonitoring() {
            this.monitoring = false;
            window.removeEventListener("resize", this.process, true);
            document.removeEventListener("scroll", this.process, true);
        }

        /**
         * Throttles a function.
         */
        throttle(fn, interval) {
            let timer = null;
            return () => {
                if (!timer) {
                    timer = setTimeout(() => {
                        fn();
                        timer = null;
                    }, interval);
                }
            };
        }

        /**
         * Gets bounding client rect for an element.
         */
        getBoundingClientRect(element) {
            return element.getBoundingClientRect();
        }

        /**
         * Computes intersection rectangle for a target element.
         */
        computeIntersection(target, rootBounds, boundingClientRect) {
            if (!rootBounds || boundingClientRect.width === 0 || boundingClientRect.height === 0) {
                return null;
            }

            const intersectionRect = {
                top: Math.max(rootBounds.top, boundingClientRect.top),
                bottom: Math.min(rootBounds.bottom, boundingClientRect.bottom),
                left: Math.max(rootBounds.left, boundingClientRect.left),
                right: Math.min(rootBounds.right, boundingClientRect.right),
            };

            intersectionRect.width = intersectionRect.right - intersectionRect.left;
            intersectionRect.height = intersectionRect.bottom - intersectionRect.top;

            return intersectionRect.width > 0 && intersectionRect.height > 0 ? intersectionRect : null;
        }

        /**
         * Gets root bounds.
         */
        getRootBounds() {
            return this.root ? this.getBoundingClientRect(this.root) : this.getViewportBounds();
        }

        /**
         * Gets the viewport bounds.
         */
        getViewportBounds() {
            return {
                top: 0,
                left: 0,
                right: window.innerWidth,
                bottom: window.innerHeight,
                width: window.innerWidth,
                height: window.innerHeight,
            };
        }

        /**
         * Determines if intersection state has changed.
         */
        hasIntersectionChanged(prevEntry, newEntry) {
            return prevEntry.isIntersecting !== newEntry.isIntersecting || prevEntry.intersectionRatio !== newEntry.intersectionRatio;
        }
    }

    // Expose the polyfill
    window.IntersectionObserver = IntersectionObserver;
    window.IntersectionObserverEntry = IntersectionObserverEntry;
})(window, document);
